/***************************************************************************
 *   Copyright (C) 2006 by Thomas Kuhndörfer
 *   tkuhndo@fh-landshut.de
 *   
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the
 *   Free Software Foundation, Inc.,
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *   (See COPYING for details.)
 ***************************************************************************
 *
 *  Module:     Scenegraph (BlackSun)
 *  File:       Mesh.h
 *  Created:    29.11.2006
 *  Author:     Thomas Kuhndörfer (tkuhndo)
 *
 **************************************************************************/

#ifndef MESH_H_
#define MESH_H_

/** \file Mesh.h
 * \brief Defines the mesh class.
 * 
 * \author Thomas Kuhndörfer.
 */

///////////////////////////////////////////////////////////
// Includes for STL
///////////////////////////////////////////////////////////
#include <list> 

///////////////////////////////////////////////////////////
// Blacksun-Includes for scenegraph-lib
///////////////////////////////////////////////////////////
#include "./SceneObject.h"
#include "./Polygon.h"
#include "./SelectionBuffer.h"
#include "./SceneAction2D.h"

namespace BSScene
{

/*! \brief The mesh object 
*
* A concrete class that is build of polygons 
*/
class Mesh : public SceneObject
{
public:

	/*!
	* \brief Constructor
	* 
	*/		
	Mesh();
	
	/*!
	* \brief Copy constructor
	* 
	* \param m Another Mesh that will be copied
	*/			
	Mesh(const Mesh &m);
	
	/*!
	* \brief Assignment constructor
	* 
	* \param copy Another Mesh that will be copied
	*/			
	Mesh&	operator=(const Mesh& copy);

	/*!
	* \brief Deconstructor
	*/		
	virtual ~Mesh();
	
	/*!
	* \brief Saves a sceneobject into a file
	* 
	* \param f The stream the data will be written to
	*/		
	void    save(QDataStream &f);
	
	/*!
	* \brief Loads a sceneobject from a file
	* 
	* \param f The stream the data will read from
	*/				
  	void    load(QDataStream &f);
  	
	/*!
	* \brief Set the name of this mesh
	* 
	* \param n The new name
	*/			  	
  	void	setName(const QString n);
  	
	/*!
	* \brief Get the name of this mesh
	* 
	* \return The name of the mesh
	*/			  	
  	QString getName() const;
  	
	/*!
	* \brief Calls the Renderer to draw this object
	* 
	* \param r The rendering device
	*/	  	  	
  	void    render(Renderer& r);

  
	/*!
	* \brief Moves the object depending on a vector
	* 
	* \param v Translation vector for the scene object
	*/	
  	void 	move(const Vector &v); 
  	
	/*!
	* \brief Rotates the object depending on a amount around a specific center
	* 
	* \param axis The rotation axis
	* \param center The center point for the rotation
	* \param amount The amount of rotation in degrees
	*/	  	
  	void    rotate(const SceneAxis axis,const Vector& center, const float amount);
  	
	/*!
	* \brief Mirror the object
	* 
	* \param axis The mirror axis
	* \param center The center point for the mirroring
	*/	  	
  	void    mirror(const SceneAxis axis,const  Vector& center);

	/*!
	* \brief Mirror the object  by world axis
	* 
	* \param axis The mirror axis
	*/	  	
  	void    mirrorWorld(const SceneAxis axis);

	/*!
	* \brief Scales an object freely on each direction 
	* 
	* \param percentageX The value of scaling the X components
	* \param percentageY The value of scaling the Y components
	* \param percentageZ The value of scaling the Z components
	*/		
	void 	scale(const double percentageX,const double percentageY,const double percentageZ);
  	
    /*!
	* \brief Hit test for selection in 2D view
	* 
	* \param boundary	Box that was generated by an selection area
	* \param axis	Axis of the view that will be the infinite component of the intersection test
	*/	
  	bool    intersects(const Aabb& boundary, const SceneAxis axis) ;  	
  	
    /*!
	* \brief Selects intersecting polygons
	* 
	* \param aabb	Box that was generated by an selection area
	* \param sb		Reference to the SelectionBuffer to add selected items
	* \param axis	Axis of the view that will be the infinite component of the intersection test
	* \param selType Additional selection information	 
	*/	  	
    void    getIntersectingPolygons(const Aabb& aabb,SelectionBuffer& sb,const SceneAxis axis, const SceneAction2D_SelectionType selType);
    
    /*!
	* \brief Selects intersecting vertices
	* 
	* \param aabb	Box that was generated by an selection area
	* \param sb		Reference to the SelectionBuffer to add selected items
	* \param axis	Axis of the view that will be the infinite component of the intersection test
	* \param selType Additional selection information	 
	*/	    
    void    getIntersectingVertices(const Aabb& aabb,SelectionBuffer& sb,const SceneAxis axis, const SceneAction2D_SelectionType selType);
      
      
    /*!
	* \brief Initialize the mesh and set the polygon array to the new one
	* 
	* \param polys	The new list of polygons
	*/	  	
    void    createFromPolygons(const vector<Polygon>& polys);
    
    /*!
	* \brief Remove a specific polygon
	* 
	* \param p	The polygon that will be removed
	*/	 
    void 	removePolygon(const Polygon* p);
    
    /*!
	* \brief Add a specific polygon
	* 
	* \param p	The polygon that will be add
	*/	     
    void 	addPolygon(const Polygon& p);
    
  	/*!
	* \brief Turns the indices order of all polygons
	* 
	*/	    
    void    changeBias();
      
  	/*!
	* \brief Selects all polygons
	* 
	* \param sb The SelectionBuffer that gets informed about the selections
	*/	          
    void    selectAllPolys(SelectionBuffer& sb);
    
    
  	/*!
	* \brief Selects all not selected polygons and deselect all selected polygons
	* 
	* \param sb The SelectionBuffer that gets informed about the selections
	*/	       
    void    selectInvert(SelectionBuffer& sb);
    
    
  	/*!
	* \brief Sets the status of all polygons to freezed
	* 
	*/	   
    void	freezeAllPolys();
    
    
  	/*!
	* \brief Sets the status of all polygons to not freezed
	* 
	*/	    
    void	freezeNoPolys();
    
    
  	/*!
	* \brief Inverts the freezed status of all polygons
	* 
	*/	    
    void    freezeInvertPolys();
    
    /*!
	* \brief Sets the status of all selected polygons to freezed
	* 
	*/	  
    void    freezeSelectedPolys();
    
  	/*!
	* \brief Sets the status of all unselected polygons to freezed
	* 
	*/	      
    void    freezeUnselectedPolys();
      
    /*!
	* \brief Sets the status of all polygons to unhidden
	* 
	*/	        
    void	hideNoPolys();
    
    /*!
	* \brief Invert the hidden status of all polygons
	* 
	*/	     
    void    hideInvertPolys();
    
    /*!
	* \brief Sets the status of all selected polygons to unhidden
	* 
	*/	     
    void    hideSelectedPolys();
    
    /*!
	* \brief Sets the status of all unselected polygons to unhidden
	* 
	*/	    
    void    hideUnselectedPolys();
      
   /*!
	* \brief Returns a polygon on a specific index
	* 
	* \param i The index of the wanted polygon
	*/	
    Polygon*  getPolygon(const int i);
    
    
  	/*!
	* \brief Calculates the bounding box of all polygons and then of the mesh itself
	* 
	*/	    
    void	recalcBoundingBox();  
    
    /*!
	* \brief Calculates the bounding box of this mesh
	* 
	*/	 
    void    calcBoundingBox();
    
    
  	/*!
	* \brief Calculates the normals of this polygon
	* 
	*/	    
    void    calcNormals();
    
    
	/*!
	* \brief Calculates the texture coordinates of this mesh
	* 
	* \param axis The mapping axis
	* \param pAabb The bounding box used to map the coordinates
	*/	
  	void    calcTextureCoords(const SceneAxis axis,const Aabb* pAabb);
  	
  	
  	/*!
	* \brief Translate the texture coordinates
	* 
	* \param dtU Changes the U value of the offset coordinates
	* \param dtV Changes the V value of the offset coordinates
	* \param drU Changes the U value of the repeat coordinates
	* \param drV Changes the V value of the repeat coordinates  
	*/	
  	void   	transTextureCoords(double dtU, double dtV, double drU, double drV);
  	
  	
  	/*!
	* \brief Get the texture coordinates
	* 
	* \param pdtU The U value of the offset coordinates
	* \param pdtV The V value of the offset coordinates
	* \param pdrU The U value of the repeat coordinates
	* \param pdrV The V value of the repeat coordinates  
	*/	
  	bool   	getTextureTrans(double *pdtU, double *pdtV,double *pdrU, double *pdrV);
    
    
    /*!
	* \brief Print out all known information about this polygon 
	* 
	*/	
    void 	print() const;
    
    /*!
	* \brief Marks this mesh als selected
	*
	*/	
    void    select();
    
    
    /*!
	* \brief Marks this mesh als not selected
	*
	*/	
    void    deSelect() ;
    
    
    /*!
	* \brief Get the polygon count
	* 
	* \return The polygon count
	*/	 
    long	countPolygons() const;
    
    
    /*!
	* \brief Get the vertices count
	* 
	* \param real True: Only real vertices will be counted 
	* 
	* \return The vertices count
	*/	 
    long 	countVertices(const bool real = true) const;
    
    
	/*!
	* \brief Compares two scene objects
	* 
	* \param so The SceneObject for comparison
	* 
	* \return Return true if it's the same objects
	*/	
  	bool operator==(const SceneObject &so) const;


	/*!
	* \brief CReturn the polygon vector of this mesh
	* 
	* \return Pointer to the array of polygons
	*/	
	vector<Polygon>*	   getPolys() 
	{ 
		return &m_polys; 
	};
	
	
	/*!
	* \brief Set the material ID of this mesh and all polygons
	* 
	* \param i ID of the new material
	*/	
	void   setMaterialID(int i);

private:

	/*!
	* \brief Initializes a mesh
	*/	
	void 	init();
	
	/*!
	* \brief Initializes a mesh using another mesh 
	*/	 		
	void 	init(const Mesh& copy);
	
	/*!
	* \brief Releases a mesh
	*/	 	
	void 	release();
	
	/*!
	* \brief Tests for intersection of the bounding box against the bounding box of this mesh 
	* 
	* \param aabb The bounding box that will be tested
	*/	 	
	bool	defaultIntersecting(const Aabb& aabb) const;
         
private:                                 
      vector<Polygon> 	m_polys;   /*!< \brief Array of all polgons for this mesh */
      bool          	m_lockAutomaticBounding;   /*!< \brief Is used for stoping bounding calculation after every work step */
      QString   		m_meshID;          /*!< \brief Name of the mesh */           
};

}

#endif /*MESH_H_*/
